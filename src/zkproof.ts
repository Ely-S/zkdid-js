import { Base64 } from 'js-base64';
import { getZKCredential, ZKCredential } from './credential';
import { getCircuit } from './circuit';
import { callApi } from './lib/tool';
import { didEqual, getDID } from './did';

// ZKP interfaces

// ZK proof (ZK Proof is a chunk of encrypted data that can be verified in privacy-preserving way)
export interface ZKProof {
  code: string;
  proof: string;
  commitment: string;
}

// A signed (e.g., by Metamask) ZKProof (useful when dApp needs to verify the ownership of the ZKProof off chain)
// A prover (e.g., Metamask address) can also prepare a `SignedZKProof` in advance before usage.
export interface SignedZKProof {
  body: ZKProof;
  signature: string;
}

/**
 * @remark This method generates a ZKProof instance based on a specific circuit code
 *         The contents in `zkCred` is always trusted by API for now.
 * @param zkCred - An instance of ZKCredential
 * @param code - The code of the circuit to apply
 * @returns An instance of ZKProof
 * @throws Error if circuit doesn't exist
 */
export const generateZKProof = async (zkCred: ZKCredential, code: string): Promise<ZKProof> => {
  // Real-world notes:
  // 1> Real-world proof generation needs actual credential data (the values decrypted by user) as input.
  await callApi();

  // The circuit MUST exist and match the `code` provided
  const circuit = getCircuit(zkCred.purpose, code);
  if (code !== circuit.toCode()) {
    throw new Error(`Expected circuit code: '${code}', got '${circuit.toCode()}'.`);
  }

  // Set field `zkproof` as `zkCred.credential` and pretend that it's well encrypted (so verifier won't see/decode).
  return {
    code,
    proof: zkCred.credential,
    commitment: zkCred.commitment,
  };
};

/**
 * @remark This method generates a signed ZKProof with prover's signature (e.g. by Metamask)
 *         The contents in `zkCred` is always trusted by API for now.
 * @param zkCred - An instance of ZKCredential
 * @param code - The code of the circuit to apply
 * @returns An instance of SignedZKProof
 * @throws Error if circuit doesn't exist
 */
const _generateSignedZKProof = async (zkCred: ZKCredential, code: string): Promise<SignedZKProof> => {
  // Generate zkproof body
  const body = await generateZKProof(zkCred, code);

  // Sign and get signature (could be implememnted by Dapp).
  const signature = 'some_signature';

  return {
    body,
    signature,
  };
};

/**
 * @remark This method verifies a ZKProof instance
 * @param zkProof - The instance of ZKProof
 * @param prover - Prover's address
 * @param purpose - The purpose of proof
 * @returns Result of proof verification
 * @throws Error if verification fails
 */
export const verifyZKProof = (zkProof: ZKProof, prover: string, purpose: string): boolean => {
  //======================Basic check======================

  // 1> Fetch DID by `address` and fetch ZKCredential by `did` and `purpose`
  const did = getDID(prover);
  const zkCred = getZKCredential(did, purpose);

  // 2> Verify `zkCred` itself (nothing to do for now since `zkCred` is always trusted by API)
  // Skip

  // 3> Prover can cheat by using a ZKProof generated by someone else.
  if (!didEqual(zkCred.did, did)) throw Error('DID on credential is not matching prover DID');

  // 4> Prevent ZKCredential misuse
  if (zkCred.purpose !== purpose) throw Error('Credential is not matching the purpose');

  //======================ZK proof check===================
  // 5> Prevent cheating
  if (zkCred.commitment !== zkProof.commitment) throw Error('Commitment is not matching');

  // 6> The circuit MUST exist
  const circuit = getCircuit(purpose, zkProof.code);

  // 7> Decode `zkProof.proof` with Base64 and parse as object.
  // For simulation, verifier pretends that he/she can't see/decode any actual values.
  const credObj: Record<string, any> = JSON.parse(Base64.decode(zkProof.proof));
  const fields = new Map();
  Object.entries(credObj).forEach(([field, value]) => {
    fields.set(field, value);
  });

  return circuit.verify(fields);
};

/**
 * @remark This method verifies a SignedZKProof instance
 * @param signed - The instance of SignedZKProof
 * @param purpose - The purpose of proof
 * @returns Result of proof verification
 * @throws Error if verification fails
 */
const _verifySignedZKProof = (signed: SignedZKProof, purpose: string): boolean => {
  // 1> Recover signer(prover) `address` (could be implememnted by Dapp).
  const address = 'some_recovered_address';

  return verifyZKProof(signed.body, address, purpose);
};
